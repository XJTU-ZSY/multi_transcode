#include"tsenc.h"
#include"windows.h"
#include"stdio.h"
#define TS_VIDEO_PID 256
#define TS_AUDIO_PID 257
//constexpr auto	TS_VIDEO_PID = 256;
//constexpr auto	TS_AUDIO_PID = 257;

//FILE* ts = fopen("ts.ts", "wb");
// ts aac stream id.
#define TS_AUDIO_AAC 0xc0
//constexpr auto TS_AUDIO_AAC = 0xc0;
// ts avc stream id.
#define TS_VIDEO_AVC 0xe0
//constexpr auto TS_VIDEO_AVC = 0xe0;
//FILE *fpp = fopen("ts.avc", "wb");
unsigned char PAT_TABLE[] = {
	/* TS */
	0x47, 0x40, 0x00, 0x10, 0x00,
	/* PSI */
	0x00, 0xb0, 0x0d, 0x00, 0x01, 0xc1, 0x00, 0x00,
	/* PAT */
	0x00, 0x01, 0xf0, 0x01,
	/* CRC */
	0x2e, 0x70, 0x19, 0x05,
	/* stuffing 167 bytes */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
static const UCHAR aucCRCHi[] = {

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,

	0x00, 0xC1, 0x81, 0x40

};

static const UCHAR aucCRCLo[] = {

	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,

	0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,

	0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,

	0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,

	0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,

	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,

	0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,

	0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,

	0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,

	0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,

	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,

	0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,

	0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,

	0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,

	0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,

	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,

	0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,

	0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,

	0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,

	0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,

	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,

	0x41, 0x81, 0x80, 0x40

};
unsigned char PMT_TABLE[] = {
	/* TS */
	0x47, 0x50, 0x01, 0x10, 0x00,
	/* PSI */
	0x02, 0xb0, 0x17, 0x00, 0x01, 0xc1, 0x00, 0x00,
	/* PMT */
	0xe1, 0x00,
	0xf0, 0x00,
	// must generate header with/without video, @see:

	0x1b, 0xe1, 0x00, 0xf0, 0x00, /* h264, pid=0x100=256 */
	0x0f, 0xe1, 0x01, 0xf0, 0x00, /* aac, pid=0x101=257 */
	0x2f, 0x44, 0xb9, 0x9b, /* crc for aac */
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff						
};
tsenc::tsenc()
{
	for (int i = 0; i < TS_PACKET_ARRAY_COUNT; i++)
	{
		ts_buf[i] = new BYTE[188];
		memset(ts_buf[i], 0, 188);
	}
	for (int i = 0; i < 100; i++)
	{
		audiobuf[i] = new unsigned char[500];
		memset(audiobuf[i], 0, 500);
	}
	infostor = new BYTE[1024];
	memset(infostor, 0, 1024);
}

tsenc::~tsenc()
{
	for (int i = 0; i < TS_PACKET_ARRAY_COUNT; i++)
		delete[] ts_buf[i];
	delete[] infostor;
}
void tsenc::writeaudio(unsigned char* p, ULONG pts, int len)
{
	pthread_mutex_lock(&audiolock);
	if (len < 500)
	{
		memcpy(audiobuf[audio_waddr], p, len);
		audiolen[audio_waddr] = len;
		audiopts[audio_waddr] = pts;
		audio_waddr++;
		audio_waddr = audio_waddr % 100;
	}
	
	pthread_mutex_unlock(&audiolock);

}
void tsenc::readaudio(ULONG pts, int roadnum)
{
	pthread_mutex_lock(&audiolock);
	if (audio_raddr == audio_waddr)
	{
		pthread_mutex_unlock(&audiolock);
		return;
	}
	while (audiopts[audio_raddr] < pts)
	{
		ts_write(audiobuf[audio_raddr], audiolen[audio_raddr], 0, audiopts[audio_raddr], 1,roadnum);
		audio_raddr++;
		audio_raddr = audio_raddr % 100;
		if (audio_raddr == audio_waddr)
			break;
	}
		pthread_mutex_unlock(&audiolock);
}
void tsenc::writeinfo(epginfo* ss)
{
	pthread_mutex_lock(&sccd);
	for (int i = 0; i < 14; i++)
		memcpy(&fuinfo[i], ss + i, sizeof(epginfo));
	pthread_mutex_unlock(&sccd);
	if (!epginfostart)
		epginfostart = true;
}

void tsenc::init()
{
	pthread_mutex_init(&sccd, NULL);
	pthread_mutex_init(&audiolock, NULL);
	w_addr = 0;
	r_addr = 0;
	audio_waddr = 0;
	audio_raddr = 0;
	lastIpts = 0;
	memcpy(ts_buf[w_addr], PAT_TABLE, sizeof(PAT_TABLE));
	numindex = 0;
	w_addr++;
	memcpy(ts_buf[w_addr], PMT_TABLE, sizeof(PMT_TABLE));
	
	w_addr++;
	perdts = 0;
	m_byVideoContinueIndex = 0;
	m_byAudioContinueIndex = 0;
	m_nTSEncapsuCount = 0;
	pindex = 1;
	for (int i = 0; i < 14; i++)
	{
		fuinfo[i].size = 0;
		fuinfo[i].idnum = 0;
	}
	epginfostart = false;
}



unsigned char* tsenc::Write_PTS_DTS(PBYTE p, BYTE fb, ULONG pts)
{
	int32_t val;

	val = fb << 4 | (((pts >> 30) & 0x07) << 1) | 1;
	*p++ = val;

	val = (((pts >> 15) & 0x7fff) << 1) | 1;
	*p++ = (val >> 8);
	*p++ = val;

	val = (((pts) & 0x7fff) << 1) | 1;
	*p++ = (val >> 8);
	*p++ = val;

	return p;
}
USHORT usMBCRC16(UCHAR * pucFrame, USHORT usLen)

{

	UCHAR ucCRCHi = 0xFF;

	UCHAR ucCRCLo = 0xFF;

	int iIndex;

	while (usLen--)

	{
		
		iIndex = ucCRCLo ^ *(pucFrame++);

		ucCRCLo = (UCHAR)(ucCRCHi ^ aucCRCHi[iIndex]);

		ucCRCHi = aucCRCLo[iIndex];
	

	}

	return (USHORT)(ucCRCHi << 8 | ucCRCLo);

}
unsigned char* tsenc::Write_PCR(unsigned char* p, int64_t pcr)
{
	*p++ = (char)(pcr >> 25);
	*p++ = (char)(pcr >> 17);
	*p++ = (char)(pcr >> 9);
	*p++ = (char)(pcr >> 1);
	*p++ = (char)(pcr << 7 | 0x7e);
	*p++ = 0;

	return p;
}
void tsenc::ts_write(PBYTE buf, mfxU32 len, ULONG dts, ULONG pts, int type, int roadnum)
{
	while (!epginfostart)
		Sleep(1);
	
	bool first = true;
	bool bKeyFrame = false;
	bool isPframe = false;
	//printf("%I64d\n", pts);
	if (type == 0)
	{
		
		bKeyFrame = CheckIsIDRFrame(buf, len);
		isPframe= CheckIsPFrame(buf, len);
		//printf("%d\n", isPframe);
		//fwrite(buf, len, 1, fpp);
	if (bKeyFrame)
	{
		/*if (pts - lastIpts != 180000)
			printf("the %d encoder is lo\n", roadnum);*/
		perdts = pts;
		lastIpts = pts;
		//numindex = 3;
	}
	else
	{
		perdts += 3600;
		//numindex++;
	}
	pts = pts + 7200;
	
	dts = perdts;

	}
	else
	{
		pts = pts + 7200;
	}

	
	while (len)
	{

		unsigned char* p = ts_buf[w_addr];
		*p++ = 0x47;
		if (type == 0)
			*p++ = (TS_VIDEO_PID >> 8) & 0x1f;
		else
			*p++ = (TS_AUDIO_PID >> 8) & 0x1f;
		// payload_unit_start_indicator; //1bit
		if (first)
		{
			p[-1] |= 0x40;
		}

			if (type == 0)
				*p++ = TS_VIDEO_PID & 0xff;
			else
				*p++ = TS_AUDIO_PID & 0xff;
			if (type == 0)
				*p++ = 0x10 | ((m_byVideoContinueIndex++) & 0x0f);
			else
				*p++ = 0x10 | ((m_byAudioContinueIndex++) & 0x0f);
			if (first)
			{
				first = false;
				if (type == 0)
				{
					pthread_mutex_lock(&sccd);
					if (bKeyFrame)
					{

						p[-1] |= 0x20; // Both Adaption and Payload
						*p++ = 19+ fuinfo[0].pdname_size+ fuinfo[0].size;    // size
						
						*p++ = 0x50; // random access + PCR
						p = Write_PCR(p, dts - 18000);
						ULONG timestamp = 0;
						timestamp = pts / 90;
						unsigned char c[2];
						c[0] = (timestamp >> 8) & 0xFF;
						c[1] = timestamp & 0xFF;
						memcpy(p, c, 2);
						p += 2;
						*p++ = fuinfo[0].pdname_size;
						memcpy(p, fuinfo[0].pdname, fuinfo[0].pdname_size);
						p+= fuinfo[0].pdname_size;
						memcpy(p, fuinfo[0].data, 2);
						p += 2;
						memcpy(p, fuinfo[0].start_time, 2);
						p += 2;
						memcpy(p, &fuinfo[0].idnum, 4);
						p += 4;
						if (fuinfo[0].size <= 128)
						{
							*p++ = fuinfo[0].size;
							memcpy(p, fuinfo[0].name, fuinfo[0].size);
							p += fuinfo[0].size;
						}
						else
						{
							*p++ = 128;
							memcpy(p, fuinfo[0].name, 128);
							p += 128;
						}
						
						pindex = 1;
					}
					else
					{
						if (isPframe)
						{
							if (pindex < 14)
							{
								p[-1] |= 0x20;
								*p++ = 11 + fuinfo[pindex].size;
								*p++ = 0x40;
								*p++ =  0x01;
								
								*p++ = fuinfo[pindex].data[0];
								*p++ = fuinfo[pindex].data[1];
								*p++ = fuinfo[pindex].start_time[0];
								*p++ = fuinfo[pindex].start_time[1];
								memcpy(p, &fuinfo[pindex].idnum, 4);
								p += 4;
								if (fuinfo[pindex].size <= 128)
								{
									*p++ = fuinfo[pindex].size;
									memcpy(p, fuinfo[pindex].name, fuinfo[pindex].size);
									p += fuinfo[pindex].size;
								}
								else
								{
									*p++ = 128;
									memcpy(p, fuinfo[pindex].name, 128);
									p += 128;
								}
								pindex++;
							}
						}
						else
						{
							p[-1] |= 0x20;
							*p++ = 0x04;
							*p++ = 0x40;
							*p++ = 0x00;
							ULONG timestamp = 0;
							timestamp = pts / 90;
							unsigned char c[2]; 
							c[0] = (timestamp >> 8) & 0xFF;
							c[1] = timestamp & 0xFF;
							memcpy(p, c, 2);
							p += 2;

			
						}
						
					}
					pthread_mutex_unlock(&sccd);
				}
					/*else
					{
						p[-1] |= 0x20;
						*p++ = 0x05;
						*p++ = 0x40;
						ULONG timestamp = 0;
						timestamp = pts / 90;
						unsigned char* c = new unsigned char[2];
						c[0] = (timestamp >> 8) & 0xFF;
						c[1] = timestamp & 0xFF;
						USHORT CRCCHAR = 0;
						CRCCHAR = usMBCRC16(c, 2);
						memcpy(p, c, 2);
						p += 2;
						memcpy(p, &CRCCHAR, 2);
						p += 2;
						delete[] c;
					}*/
				
			*p++ = 0x00;
			*p++ = 0x00;
			*p++ = 0x01;
			//8bits
			if (type == 0)
				*p++ = TS_VIDEO_AVC;
			else
				*p++ = TS_AUDIO_AAC;

			// pts(33bits) need 5bytes.
			BYTE header_size = 5;
			BYTE flags = 0x80; // pts

							   // dts(33bits) need 5bytes also
			if (type == 0)
			{
				if (dts != pts) {
					header_size += 5;
					flags |= 0x40; // dts
				}
			}

			// 3bytes: flag fields from PES_packet_length to PES_header_data_length
			int pes_size = len + header_size + 3;
			if (pes_size > 0xffff) {
				/**
				* when actual packet length > 0xffff(65535),
				* which exceed the max u_int16_t packet length,
				* use 0 packet length, the next unit start indicates the end of packet.
				*/
				pes_size = 0;
			}

			// PES_packet_length; //16bits
			*p++ = (pes_size >> 8);
			*p++ = pes_size;

			// PES_scrambling_control; //2bits, '10'
			// PES_priority; //1bit
			// data_alignment_indicator; //1bit
			// copyright; //1bit
			// original_or_copy; //1bit
			*p++ = 0x80; /* H222 */

						 // PTS_DTS_flags; //2bits
						 // ESCR_flag; //1bit
						 // ES_rate_flag; //1bit
						 // DSM_trick_mode_flag; //1bit
						 // additional_copy_info_flag; //1bit
						 // PES_CRC_flag; //1bit
						 // PES_extension_flag; //1bit
			*p++ = flags;

			// PES_header_data_length; //8bits
			*p++ = header_size;

			// pts; // 33bits
			p = Write_PTS_DTS(p, flags >> 6,pts);
			// dts; // 33bits
			if (type == 0)
			{
				if (dts != pts)
				{
					p = Write_PTS_DTS(p, 1, dts);
				}
			}
		}
		int body_size = TS_PACKET_LEN - (p - ts_buf[w_addr]);
		if (body_size <= len)
		{
			memcpy(p, buf, body_size);
			
			buf += body_size;
			len -= body_size;
			w_addr++;

			w_addr = w_addr % TS_PACKET_ARRAY_COUNT;
			m_nTSEncapsuCount++;
			if (m_nTSEncapsuCount >0 && m_nTSEncapsuCount % 40 == 0)
			{
				m_byPATPMTContinue++;
				m_byPATPMTContinue &= 0x0F;
				PAT_TABLE[3] &= 0xF0;
				PAT_TABLE[3] |= m_byPATPMTContinue;

				PMT_TABLE[3] &= 0xF0;
				PMT_TABLE[3] |= m_byPATPMTContinue;
				memcpy(ts_buf[w_addr], PAT_TABLE, sizeof(PAT_TABLE));
				
				++w_addr;
				w_addr = w_addr%TS_PACKET_ARRAY_COUNT;
				memcpy(ts_buf[w_addr], PMT_TABLE, sizeof(PMT_TABLE));
				
				++w_addr;
				w_addr = w_addr%TS_PACKET_ARRAY_COUNT;
			}
		}
		else 
		{
			p = Fill_Stuff(p, ts_buf[w_addr], body_size, len);
			memcpy(p, buf, len);
			
			w_addr++;

			w_addr = w_addr % TS_PACKET_ARRAY_COUNT;
			m_nTSEncapsuCount++;
			if (m_nTSEncapsuCount >0 && m_nTSEncapsuCount % 40 == 0)
			{
				m_byPATPMTContinue++;
				m_byPATPMTContinue &= 0x0F;
				PAT_TABLE[3] &= 0xF0;
				PAT_TABLE[3] |= m_byPATPMTContinue;

				PMT_TABLE[3] &= 0xF0;
				PMT_TABLE[3] |= m_byPATPMTContinue;
				memcpy(ts_buf[w_addr], PAT_TABLE, sizeof(PAT_TABLE));
				
				++w_addr;
				w_addr = w_addr%TS_PACKET_ARRAY_COUNT;
				memcpy(ts_buf[w_addr], PMT_TABLE, sizeof(PMT_TABLE));
			
				++w_addr;
				w_addr = w_addr%TS_PACKET_ARRAY_COUNT;
			}
			
			break;
		}
		
	}
}
bool tsenc::CheckIsPFrame(BYTE *pByte, mfxU32 nBufLen)
{
	int i = 0;
	bool bRetVal = false;
	while (i<nBufLen - 4)
	{
		if (pByte[i++] == 0x00 &&
			pByte[i++] == 0x00 &&
			pByte[i++] == 0x00 &&
			pByte[i++] == 0x01)
		{
			int pos = i;
			while (pos < nBufLen - 4)
			{
				if (
		         	pByte[pos++] == 0x00 &&
					pByte[pos++] == 0x00 &&
					pByte[pos++] == 0x01)
				{
					if (pByte[pos - 4] != 0x00 && pByte[pos++] == 0x21)
					{
						bRetVal = true;
						break;
					}

				}
				
			}
			break;
		}
	}
	return bRetVal;
}
bool tsenc::CheckIsIDRFrame(BYTE *pByte, mfxU32 nBufLen)
{
	int i = 0;
	bool bRetVal = false;
	while (i<nBufLen - 4)
	{
		if (pByte[i++] == 0x00 &&
			pByte[i++] == 0x00 &&
			pByte[i++] == 0x00 &&
			pByte[i++] == 0x01)
		{
			int pos = i;
			while(pos<nBufLen-4)
			{
				PDWORD pData = (PDWORD)(&pByte[pos]);
				if (*pData == 0x1000000)
				{// 若等于 00 00 00 01，则代表找到了非VCL的NALU
					pos += 4;
					i = pos;
					pos++;
					continue;
				}
				else
				{// 若不等于 00 00 00 01
					if (((*pData) << 8) == 0x1000000)
					{// 若等于 00 00 01，则代表找到了VCL的NALU
						pos += 3;
						bRetVal = ((pByte[pos] & 0x1f) == 0x05) ? true : false;
						break;
					}
				}
				pos++;
			}
		}
	}
	return bRetVal;
}
unsigned char* tsenc::Fill_Stuff(unsigned char* pes_body_end, PBYTE packet, int body_size, mfxU32 in_size)
{
	unsigned char* p = pes_body_end;

	// insert the stuff bytes before PES body
	int stuff_size = (body_size - in_size);

	// adaption_field_control; //2bits
	if (packet[3] & 0x20)
	{
		//  has adaptation
		// packet[4]: adaption_field_length
		// packet[5]: adaption field data
		// base: start of PES body
		unsigned char* base = &packet[5] + packet[4];
		int len = p - base;
		p = (unsigned char*)memmove(base + stuff_size, base, len) + len;
		// increase the adaption field size.
		packet[4] += stuff_size;

		return p;
	}

	// create adaption field.
	// adaption_field_control; //2bits
	packet[3] |= 0x20;
	// base: start of PES body
	unsigned char* base = &packet[4];
	int len = p - base;
	p = (unsigned char*)memmove(base + stuff_size, base, len) + len;
	// adaption_field_length; //8bits
	packet[4] = (stuff_size - 1);
	if (stuff_size >= 2)
	{
		// adaption field flags.
		packet[5] = 0;
		// adaption data.
		if (stuff_size > 2) {
			memset(&packet[6], 0xff, stuff_size - 2);
		}
	}
	return p;
}

